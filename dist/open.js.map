{"version":3,"sources":["webpack:///./src/common.js","webpack:///./src/gameTime.js","webpack:///./src/open.js","webpack:///./src/sample.js","webpack:///../node_modules/bit-twiddle/twiddle.js","webpack:///../node_modules/fft-js/index.js","webpack:///../node_modules/fft-js/src/complex.js","webpack:///../node_modules/fft-js/src/dft.js","webpack:///../node_modules/fft-js/src/fft.js","webpack:///../node_modules/fft-js/src/fftutil.js","webpack:///../node_modules/fft-js/src/idft.js","webpack:///../node_modules/fft-js/src/ifft.js","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":[],"mappings":";;;;;;;AAAa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,kC;;;;;;;;ACrCa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oC;;;;;;;;AC7Da;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,GAAU;AACnC,mBAAmB,mBAAO,CAAC,GAAY;AACvC,iBAAiB,mBAAO,CAAC,GAAU;AACnC,yBAAyB,mBAAO,CAAC,GAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA,wBAAwB,kBAAkB,EAAE;AAC5C;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gC;;;;;;;;AC3Ua;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;;AAEA;AACA,gBAAgB;AAChB,eAAe;AACf,eAAe;;AAEf;AACA,YAAY;AACZ;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,YAAY;AACZ;AACA,4BAA4B;AAC5B,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA,kBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4BAAwB;AACjC,UAAU,6BAA0B;AACpC,gBAAgB,mCAA+B;AAC/C,UAAU,mBAAO,CAAC,EAAe;AACjC,SAAS,mBAAO,CAAC,GAAW;AAC5B,UAAU,mBAAO,CAAC,GAAY;AAC9B;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,GAAW;AACjC,cAAc,mBAAO,CAAC,EAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB,kBAAkB;;AAElB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,qCAAqC;AACrC;AACA;;AAEA;AACA;;AAEA,qB;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,GAAW;AACjC,cAAc,mBAAO,CAAC,EAAW;AACjC,cAAc,mBAAO,CAAC,GAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;;AAEtD;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B,qBAAqB,aAAa;AAClC;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,GAAW;;;AAGjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA,0EAA0E;;AAE1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,GAAO;;AAEzB;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA,sB;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,4BAAoB;;;AAG9B;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;;;;;;;UChDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;UCrBA;UACA;UACA;UACA","file":"open.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Common = void 0;\nclass Common {\n    static getContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Common.audioCtx) {\n                return Common.audioCtx;\n            }\n            return new Promise((resolve) => {\n                const context = new window.AudioContext();\n                if (context.state === 'running') {\n                    resolve(context);\n                }\n                else {\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        resolve(yield Common.getContext());\n                    }), 500);\n                }\n            });\n        });\n    }\n    static indexToTheta(index) {\n        return (index * 2 * Math.PI) / 16 - Math.PI;\n    }\n}\nexports.Common = Common;\nCommon.audioCtx = null;\n//# sourceMappingURL=common.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameTime = void 0;\nconst common_1 = require(\"./common\");\nclass GameTime {\n    constructor(bpm) {\n        console.assert(bpm);\n        this.bpm = bpm;\n        this.elapsedMs = 0;\n        this.running = false;\n        this.audioCtx = null;\n        this.audioCtxZero = 0;\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.audioCtx = yield common_1.Common.getContext();\n        });\n    }\n    start() {\n        if (this.audioCtx) {\n            this.running = true;\n            this.audioCtxZero = this.audioCtx.currentTime - this.elapsedMs * 1000;\n        }\n    }\n    getBpm() {\n        return this.bpm;\n    }\n    getElapsedMs() {\n        return this.elapsedMs;\n    }\n    getAudioTimeForGameTime(gameMs) {\n        return this.audioCtxZero + gameMs / 1000;\n    }\n    getAudioTimeNow() {\n        return this.audioCtxZero + this.elapsedMs / 1000;\n    }\n    roundQuantizeAudioTime(audioTimeS) {\n        const secondsPerBeat = 60 / this.bpm / 4;\n        const beat = Math.round(audioTimeS / secondsPerBeat);\n        return beat * secondsPerBeat;\n    }\n    getRoundQuantizedAudioTimeNow() {\n        return this.roundQuantizeAudioTime(this.getAudioTimeNow());\n    }\n    tick(timeMs, timeDeltaMs) {\n        if (this.running) {\n            this.elapsedMs += timeDeltaMs;\n        }\n    }\n}\nexports.GameTime = GameTime;\n//# sourceMappingURL=gameTime.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = require(\"./common\");\nconst gameTime_1 = require(\"./gameTime\");\nconst sample_1 = require(\"./sample\");\nconst FFT = __importStar(require(\"fft-js\"));\nconst url = new URL(document.URL);\nfunction transients(frames) {\n    const result = [];\n    let sum = 0.0;\n    const bufferSize = Math.round(44000 / 20);\n    for (let i = frames.length - bufferSize; i < frames.length; ++i) {\n        sum += frames[i] * frames[i];\n    }\n    let lastTransient = -bufferSize;\n    for (let i = 0; i < frames.length; ++i) {\n        const x2 = frames[i] * frames[i];\n        if ((x2 > 0.02) && (x2 / (sum / bufferSize) > 10)) {\n            if (i - lastTransient >= bufferSize) {\n                result.push(i);\n                lastTransient = i;\n            }\n        }\n        const prevX = frames[(i - bufferSize + frames.length) % frames.length];\n        sum += x2 - prevX * prevX;\n    }\n    return result;\n}\nfunction topNIndexes(arr, n) {\n    const kvs = [];\n    for (const [i, x] of arr.entries()) {\n        kvs.push({ k: i, v: x });\n    }\n    kvs.sort((a, b) => { return b.v - a.v; });\n    const result = [];\n    for (let i = 0; i < n; ++i) {\n        result.push(kvs[i].k);\n    }\n    return result;\n}\nfunction foldFrequencies(magnitudes) {\n    const target = new Float32Array(magnitudes.length);\n    for (let base = 1; base < magnitudes.length; ++base) {\n        for (let source = base; source < magnitudes.length; source += base) {\n            target[base] += magnitudes[source];\n        }\n    }\n    return target;\n}\nfunction renderWave(canvas, buffer, audioCtx) {\n    console.log('render');\n    const windowSize = 16384;\n    const ctx = canvas.getContext('2d');\n    let offset = 0;\n    let t = Math.PI;\n    const numFFTs = buffer.length / windowSize * 16;\n    while (offset + windowSize < buffer.length) {\n        const samples = new Float32Array(windowSize);\n        for (let i = 0; i < windowSize; ++i) {\n            samples[i] = buffer[i + offset];\n        }\n        const fourier = FFT.fft(samples);\n        const frequencies = FFT.util.fftFreq(fourier, audioCtx.sampleRate);\n        const rawMagnitudes = FFT.util.fftMag(fourier);\n        const magnitudes = foldFrequencies(rawMagnitudes);\n        const indices = topNIndexes(magnitudes, 12);\n        ctx.fillStyle = '#444';\n        for (const index of indices) {\n            const freq = frequencies[index];\n            if (freq == 0) {\n                continue;\n            }\n            const mag = magnitudes[index];\n            const r = 60 * Math.log(freq);\n            const x = r * Math.cos(t) + canvas.width / 2;\n            const y = r * Math.sin(t) + canvas.height / 2;\n            ctx.beginPath();\n            ctx.arc(x, y, mag / 50, -Math.PI, Math.PI);\n            ctx.fill();\n        }\n        t -= 2 * Math.PI / numFFTs * (10 / 12);\n        // Overlapping windows\n        offset += Math.round(windowSize / 16);\n    }\n}\nfunction renderBuffer(ctx, canvas, audioCtx, frames, bpm) {\n    const framesPerBeat = Math.round(audioCtx.sampleRate * 60 / bpm);\n    const t = transients(frames);\n    ctx.fillStyle = '#6f6';\n    for (const i of t) {\n        ctx.fillRect(Math.round(i / frames.length * 1000) - 1, 0, 3, canvas.height);\n    }\n    let x = 0;\n    ctx.fillStyle = '#f992';\n    let framesUntilNextBeat = 0;\n    for (let i = 0; i < frames.length; ++i) {\n        const y = 200 * frames[i];\n        ctx.fillRect(x, 300 - y, 1, 2 * y);\n        framesUntilNextBeat -= 1;\n        x += 1000 / frames.length;\n    }\n}\nfunction renderBars(canvas, frames, audioCtx, bpm) {\n    const ctx = canvas.getContext('2d');\n    const framesPerBeat = Math.round(audioCtx.sampleRate * 60 / bpm);\n    let x = 0;\n    ctx.fillStyle = '#f992';\n    let framesUntilNextBeat = 0;\n    for (let i = 0; i < frames.length; ++i) {\n        if (framesUntilNextBeat <= 0) {\n            framesUntilNextBeat += framesPerBeat;\n            ctx.fillStyle = 'black';\n            ctx.fillRect(Math.round(x), 100, 1, canvas.height - 200);\n            ctx.fillStyle = '#f992';\n        }\n        framesUntilNextBeat -= 1;\n        x += 1000 / frames.length;\n    }\n}\nfunction initCanvas(body) {\n    const peaksCanvas = document.createElement('canvas');\n    peaksCanvas.id = 'peaks';\n    peaksCanvas.width = 1000;\n    peaksCanvas.height = 600;\n    peaksCanvas.style.setProperty('visibility', 'hidden');\n    body.appendChild(peaksCanvas);\n    const barsCanvas = document.createElement('canvas');\n    barsCanvas.id = 'bars';\n    barsCanvas.width = 1000;\n    barsCanvas.height = 600;\n    body.appendChild(barsCanvas);\n    const selectionCanvas = document.createElement('canvas');\n    selectionCanvas.id = 'selection';\n    selectionCanvas.width = 1000;\n    selectionCanvas.height = 600;\n    body.appendChild(selectionCanvas);\n    return [peaksCanvas, barsCanvas, selectionCanvas];\n}\nclass Granules {\n    constructor(audioBuffer, audioCtx) {\n        this.audioBuffer = audioBuffer;\n        this.numSamples = audioBuffer.getChannelData(0).length;\n        this.audioCtx = audioCtx;\n        this.controlPoints = [0, this.numSamples / audioCtx.sampleRate];\n        this.playbackPoints = [0, this.numSamples / audioCtx.sampleRate];\n        this.activePoint = 0;\n    }\n    getXForPoint(index, canvas) {\n        const x = (canvas.width * this.controlPoints[index]) /\n            (this.numSamples / this.audioCtx.sampleRate);\n        return x;\n    }\n    getXForPlayback(index, canvas) {\n        const x = (canvas.width * this.playbackPoints[index]) /\n            (this.numSamples / this.audioCtx.sampleRate);\n        return x;\n    }\n    render(canvas, peaksCanvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = '#66f';\n        for (let i = 0; i < this.controlPoints.length - 1; ++i) {\n            const width = this.getXForPoint(i + 1, canvas) -\n                this.getXForPoint(i, canvas);\n            if (i === this.activePoint) {\n                ctx.fillStyle = '#aaf';\n            }\n            else if (i % 2 === 0) {\n                ctx.fillStyle = '#aaa';\n            }\n            else {\n                ctx.fillStyle = '#ddd';\n            }\n            ctx.fillRect(this.getXForPlayback(i, canvas), 0, width, canvas.height);\n            ctx.drawImage(peaksCanvas, this.getXForPoint(i, canvas), 0, width, canvas.height, this.getXForPlayback(i, canvas), 0, width, canvas.height);\n        }\n    }\n    changeStart(delta) {\n        this.controlPoints[this.activePoint] =\n            Math.max(0, this.controlPoints[this.activePoint] + delta);\n        this.playbackPoints[this.activePoint] =\n            Math.max(0, this.playbackPoints[this.activePoint] + delta);\n    }\n    changePlayStart(delta) {\n        this.playbackPoints[this.activePoint] =\n            Math.max(0, this.playbackPoints[this.activePoint] + delta);\n    }\n    changeEnd(delta) {\n        this.controlPoints[this.activePoint + 1] += delta;\n        this.playbackPoints[this.activePoint + 1] += delta;\n    }\n    next(dir) {\n        this.activePoint += dir;\n        this.activePoint = this.activePoint % (this.controlPoints.length - 1);\n    }\n    play() {\n        console.log('playing');\n        const audioNode = this.audioCtx.createBufferSource();\n        audioNode.buffer = this.audioBuffer;\n        audioNode.connect(this.audioCtx.destination);\n        const duration = this.controlPoints[this.activePoint + 1]\n            - this.controlPoints[this.activePoint];\n        audioNode.start(0, this.controlPoints[this.activePoint], duration);\n    }\n    splitInternal(a, i) {\n        const mid = (a[i] + a[i + 1]) / 2;\n        a.splice(i + 1, 0, mid);\n        return mid;\n    }\n    split() {\n        this.splitInternal(this.controlPoints, this.activePoint);\n        this.splitInternal(this.playbackPoints, this.activePoint);\n    }\n    join() {\n        if (this.controlPoints.length > 2 && this.activePoint > 0) {\n            this.controlPoints.splice(this.activePoint, 1);\n            this.playbackPoints.splice(this.activePoint, 1);\n        }\n    }\n}\nfunction getBpmFromFrames(numFrames, audioCtx) {\n    const durationS = numFrames / audioCtx.sampleRate;\n    let bpm = 60 / durationS;\n    while (bpm < 120 * Math.sqrt(0.5)) {\n        bpm *= 2;\n    }\n    return bpm;\n}\nfunction go() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const audioCtx = yield common_1.Common.getContext();\n        const sampleUri = url.searchParams.get('s');\n        const gameTime = new gameTime_1.GameTime(120);\n        const sample = new sample_1.Sample(sampleUri, gameTime);\n        const buffer = yield sample.getData();\n        const body = document.getElementsByTagName('body')[0];\n        const [peaksCanvas, barsCanvas, selectionCanvas] = initCanvas(body);\n        barsCanvas.tabIndex = 0;\n        const peaksCtx = peaksCanvas.getContext('2d');\n        const frames = buffer.getChannelData(0);\n        const bpm = getBpmFromFrames(frames.length, audioCtx);\n        const granules = new Granules(buffer, audioCtx);\n        const waveCanvas = document.createElement('canvas');\n        waveCanvas.width = 1000;\n        waveCanvas.height = 1000;\n        waveCanvas.style.setProperty('position', 'absolute');\n        waveCanvas.style.setProperty('top', '500px');\n        renderWave(waveCanvas, frames, audioCtx);\n        body.appendChild(waveCanvas);\n        peaksCtx.clearRect(0, 0, peaksCanvas.width, peaksCanvas.height);\n        renderBuffer(peaksCtx, peaksCanvas, audioCtx, frames, bpm);\n        renderBars(barsCanvas, frames, audioCtx, bpm);\n        granules.render(selectionCanvas, peaksCanvas);\n        barsCanvas.addEventListener('keydown', (ev) => {\n            let actionTaken = true;\n            switch (ev.code) {\n                case 'KeyS':\n                    granules.split();\n                    break;\n                case 'KeyJ':\n                    granules.changePlayStart(-0.01);\n                    break;\n                case 'KeyK':\n                    granules.changePlayStart(0.01);\n                    break;\n                case 'Delete':\n                case 'Backspace':\n                    granules.join();\n                    break;\n                case 'ArrowLeft':\n                    granules.changeStart(-0.01);\n                    break;\n                case 'ArrowRight':\n                    granules.changeStart(0.01);\n                    break;\n                case 'ArrowDown':\n                    granules.changeEnd(-0.01);\n                    break;\n                case 'ArrowUp':\n                    granules.changeEnd(0.01);\n                    break;\n                case 'Tab':\n                    if (ev.shiftKey) {\n                        granules.next(-1);\n                    }\n                    else {\n                        granules.next(1);\n                    }\n                    break;\n                case 'Space':\n                    granules.play();\n                    break;\n            }\n            if (actionTaken) {\n                console.log(`Action: ${ev.code}`);\n                ev.preventDefault();\n                selectionCanvas.getContext('2d')\n                    .clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);\n                granules.render(selectionCanvas, peaksCanvas);\n            }\n        });\n    });\n}\ngo();\n//# sourceMappingURL=open.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Sample = void 0;\nconst common_1 = require(\"./common\");\nclass Sample {\n    constructor(url, gameTime) {\n        this.url = url;\n        this.gameTime = gameTime;\n        this.audioCtx = null;\n        this.buffer = null;\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.buffer = yield this.getData();\n        });\n    }\n    getData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.audioCtx = yield common_1.Common.getContext();\n            const request = new XMLHttpRequest();\n            request.open('GET', this.url, true);\n            request.responseType = 'arraybuffer';\n            return new Promise((resolve, reject) => {\n                request.onload = () => {\n                    const audioData = request.response;\n                    this.audioCtx.decodeAudioData(audioData, function (buffer) {\n                        resolve(buffer);\n                    }, reject);\n                };\n                request.send();\n            });\n        });\n    }\n    _play(audioTimeS) {\n        if (!this.audioCtx || !this.buffer) {\n            console.error('Sample is not loaded!');\n            return;\n        }\n        const audioNode = this.audioCtx.createBufferSource();\n        audioNode.buffer = this.buffer;\n        audioNode.connect(this.audioCtx.destination);\n        const nowAudioTime = this.audioCtx.currentTime;\n        const timeInFuture = audioTimeS - nowAudioTime;\n        audioNode.start(nowAudioTime + Math.max(timeInFuture, 0), Math.max(0, -timeInFuture));\n    }\n    playQuantized(gameTimeMs) {\n        const audioTimeS = this.gameTime.getAudioTimeForGameTime(gameTimeMs);\n        const quantizedAudioTimeS = this.gameTime.roundQuantizeAudioTime(audioTimeS);\n        this._play(quantizedAudioTimeS);\n    }\n}\nexports.Sample = Sample;\n//# sourceMappingURL=sample.js.map","/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\nmodule.exports = {\n    fft: require('./src/fft').fft,\n    ifft: require('./src/ifft').ifft,\n    fftInPlace: require('./src/fft').fftInPlace,\n    util: require('./src/fftutil'),\n    dft: require('./src/dft'),\n    idft: require('./src/idft')\n};\n","//-------------------------------------------------\n// Add two complex numbers\n//-------------------------------------------------\nvar complexAdd = function (a, b)\n{\n    return [a[0] + b[0], a[1] + b[1]];\n};\n\n//-------------------------------------------------\n// Subtract two complex numbers\n//-------------------------------------------------\nvar complexSubtract = function (a, b)\n{\n    return [a[0] - b[0], a[1] - b[1]];\n};\n\n//-------------------------------------------------\n// Multiply two complex numbers\n//\n// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n//-------------------------------------------------\nvar complexMultiply = function (a, b) \n{\n    return [(a[0] * b[0] - a[1] * b[1]), \n            (a[0] * b[1] + a[1] * b[0])];\n};\n\n//-------------------------------------------------\n// Calculate |a + bi|\n//\n// sqrt(a*a + b*b)\n//-------------------------------------------------\nvar complexMagnitude = function (c) \n{\n    return Math.sqrt(c[0]*c[0] + c[1]*c[1]); \n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    add: complexAdd,\n    subtract: complexSubtract,\n    multiply: complexMultiply,\n    magnitude: complexMagnitude\n};\n","/*===========================================================================*\\\n * Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//------------------------------------------------\nvar complex = require('./complex');\nvar fftUtil = require('./fftutil');\n\n//-------------------------------------------------\n// Calculate brute-force O(n^2) DFT for vector.\n//-------------------------------------------------\nvar dft = function(vector) {\n  var X = [],\n      N = vector.length;\n\n  for (var k = 0; k < N; k++) {\n    X[k] = [0, 0]; //Initialize to a 0-valued complex number.\n\n    for (var i = 0; i < N; i++) {\n      var exp = fftUtil.exponent(k * i, N);\n      var term;\n      if (Array.isArray(vector[i]))\n        term = complex.multiply(vector[i], exp)//If input vector contains complex numbers\n      else\n        term = complex.multiply([vector[i], 0], exp);//Complex mult of the signal with the exponential term.  \n      X[k] = complex.add(X[k], term); //Complex summation of X[k] and exponential\n    }\n  }\n\n  return X;\n};\n\nmodule.exports = dft;","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex'),\n    fftUtil = require('./fftutil'),\n    twiddle = require('bit-twiddle');\n\nmodule.exports = {\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.\n  //-------------------------------------------------\n  fft: function fft(vector) {\n    var X = [],\n        N = vector.length;\n\n    // Base case is X = x + 0i since our input is assumed to be real only.\n    if (N == 1) {\n      if (Array.isArray(vector[0])) //If input vector contains complex numbers\n        return [[vector[0][0], vector[0][1]]];      \n      else\n        return [[vector[0], 0]];\n    }\n\n    // Recurse: all even samples\n    var X_evens = fft(vector.filter(even)),\n\n        // Recurse: all odd samples\n        X_odds  = fft(vector.filter(odd));\n\n    // Now, perform N/2 operations!\n    for (var k = 0; k < N / 2; k++) {\n      // t is a complex number!\n      var t = X_evens[k],\n          e = complex.multiply(fftUtil.exponent(k, N), X_odds[k]);\n\n      X[k] = complex.add(t, e);\n      X[k + (N / 2)] = complex.subtract(t, e);\n    }\n\n    function even(__, ix) {\n      return ix % 2 == 0;\n    }\n\n    function odd(__, ix) {\n      return ix % 2 == 1;\n    }\n\n    return X;\n  },\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.  This is the in-\n  // place implementation, to avoid the memory\n  // footprint used by recursion.\n  //-------------------------------------------------\n  fftInPlace: function(vector) {\n    var N = vector.length;\n\n    var trailingZeros = twiddle.countTrailingZeros(N); //Once reversed, this will be leading zeros\n\n    // Reverse bits\n    for (var k = 0; k < N; k++) {\n      var p = twiddle.reverse(k) >>> (twiddle.INT_BITS - trailingZeros);\n      if (p > k) {\n        var complexTemp = [vector[k], 0];\n        vector[k] = vector[p];\n        vector[p] = complexTemp;\n      } else {\n        vector[p] = [vector[p], 0];\n      }\n    }\n\n    //Do the DIT now in-place\n    for (var len = 2; len <= N; len += len) {\n      for (var i = 0; i < len / 2; i++) {\n        var w = fftUtil.exponent(i, len);\n        for (var j = 0; j < N / len; j++) {\n          var t = complex.multiply(w, vector[j * len + i + len / 2]);\n          vector[j * len + i + len / 2] = complex.subtract(vector[j * len + i], t);\n          vector[j * len + i] = complex.add(vector[j * len + i], t);\n        }\n      }\n    }\n  }\n};\n","/*===========================================================================*\\\n * Fast Fourier Transform Frequency/Magnitude passes\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex');\n\n\n//-------------------------------------------------\n// By Eulers Formula:\n//\n// e^(i*x) = cos(x) + i*sin(x)\n//\n// and in DFT:\n//\n// x = -2*PI*(k/N)\n//-------------------------------------------------\nvar mapExponent = {},\n    exponent = function (k, N) {\n      var x = -2 * Math.PI * (k / N);\n\n      mapExponent[N] = mapExponent[N] || {};\n      mapExponent[N][k] = mapExponent[N][k] || [Math.cos(x), Math.sin(x)];// [Real, Imaginary]\n\n      return mapExponent[N][k];\n};\n\n//-------------------------------------------------\n// Calculate FFT Magnitude for complex numbers.\n//-------------------------------------------------\nvar fftMag = function (fftBins) {\n    var ret = fftBins.map(complex.magnitude);\n    return ret.slice(0, ret.length / 2);\n};\n\n//-------------------------------------------------\n// Calculate Frequency Bins\n// \n// Returns an array of the frequencies (in hertz) of\n// each FFT bin provided, assuming the sampleRate is\n// samples taken per second.\n//-------------------------------------------------\nvar fftFreq = function (fftBins, sampleRate) {\n    var stepFreq = sampleRate / (fftBins.length);\n    var ret = fftBins.slice(0, fftBins.length / 2);\n\n    return ret.map(function (__, ix) {\n        return ix * stepFreq;\n    });\n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    fftMag: fftMag,\n    fftFreq: fftFreq,\n    exponent: exponent\n};\n","/*===========================================================================*\\\n * Inverse Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar dft = require('./dft');\n\nfunction idft(signal) {\n    //Interchange real and imaginary parts\n    var csignal = [];\n    for (var i = 0; i < signal.length; i++) {\n        csignal[i] = [signal[i][1], signal[i][0]];\n    }\n\n    //Apply dft\n    var ps = dft(csignal);\n\n    //Interchange real and imaginary parts and normalize\n    var res = [];\n    for (var j = 0; j < ps.length; j++) {\n        res[j] = [ps[j][1] / ps.length, ps[j][0] / ps.length];\n    }\n    return res;\n}\n\nmodule.exports = idft;","/*===========================================================================*\\\n * Inverse Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\n\nvar fft = require('./fft').fft;\n\n\nmodule.exports = {\n    ifft: function ifft(signal){\n        //Interchange real and imaginary parts\n        var csignal=[];\n        for(var i=0; i<signal.length; i++){\n            csignal[i]=[signal[i][1], signal[i][0]];\n        }\n    \n        //Apply fft\n        var ps=fft(csignal);\n        \n        //Interchange real and imaginary parts and normalize\n        var res=[];\n        for(var j=0; j<ps.length; j++){\n            res[j]=[ps[j][1]/ps.length, ps[j][0]/ps.length];\n        }\n        return res;\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(367);\n"],"sourceRoot":""}