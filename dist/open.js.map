{"version":3,"sources":["webpack:///./src/common.js","webpack:///./src/gameTime.js","webpack:///./src/open.js","webpack:///./src/sample.js","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":[],"mappings":";;;;;;;AAAa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,kC;;;;;;;ACrCa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB;AAChB,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oC;;;;;;;AC7Da;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,GAAU;AACnC,mBAAmB,mBAAO,CAAC,GAAY;AACvC,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gC;;;;;;;AC3La;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;UCpEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;UCrBA;UACA;UACA;UACA","file":"open.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Common = void 0;\nclass Common {\n    static getContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Common.audioCtx) {\n                return Common.audioCtx;\n            }\n            return new Promise((resolve) => {\n                const context = new window.AudioContext();\n                if (context.state === 'running') {\n                    resolve(context);\n                }\n                else {\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        resolve(yield Common.getContext());\n                    }), 500);\n                }\n            });\n        });\n    }\n    static indexToTheta(index) {\n        return (index * 2 * Math.PI) / 16 - Math.PI;\n    }\n}\nexports.Common = Common;\nCommon.audioCtx = null;\n//# sourceMappingURL=common.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameTime = void 0;\nconst common_1 = require(\"./common\");\nclass GameTime {\n    constructor(bpm) {\n        console.assert(bpm);\n        this.bpm = bpm;\n        this.elapsedMs = 0;\n        this.running = false;\n        this.audioCtx = null;\n        this.audioCtxZero = 0;\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.audioCtx = yield common_1.Common.getContext();\n        });\n    }\n    start() {\n        if (this.audioCtx) {\n            this.running = true;\n            this.audioCtxZero = this.audioCtx.currentTime - this.elapsedMs * 1000;\n        }\n    }\n    getBpm() {\n        return this.bpm;\n    }\n    getElapsedMs() {\n        return this.elapsedMs;\n    }\n    getAudioTimeForGameTime(gameMs) {\n        return this.audioCtxZero + gameMs / 1000;\n    }\n    getAudioTimeNow() {\n        return this.audioCtxZero + this.elapsedMs / 1000;\n    }\n    roundQuantizeAudioTime(audioTimeS) {\n        const secondsPerBeat = 60 / this.bpm / 4;\n        const beat = Math.round(audioTimeS / secondsPerBeat);\n        return beat * secondsPerBeat;\n    }\n    getRoundQuantizedAudioTimeNow() {\n        return this.roundQuantizeAudioTime(this.getAudioTimeNow());\n    }\n    tick(timeMs, timeDeltaMs) {\n        if (this.running) {\n            this.elapsedMs += timeDeltaMs;\n        }\n    }\n}\nexports.GameTime = GameTime;\n//# sourceMappingURL=gameTime.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = require(\"./common\");\nconst gameTime_1 = require(\"./gameTime\");\nconst sample_1 = require(\"./sample\");\nconst url = new URL(document.URL);\nfunction transients(frames) {\n    const result = [];\n    let sum = 0.0;\n    const bufferSize = Math.round(44000 / 20);\n    for (let i = frames.length - bufferSize; i < frames.length; ++i) {\n        sum += frames[i] * frames[i];\n    }\n    let lastTransient = -bufferSize;\n    for (let i = 0; i < frames.length; ++i) {\n        const x2 = frames[i] * frames[i];\n        if ((x2 > 0.02) && (x2 / (sum / bufferSize) > 10)) {\n            if (i - lastTransient >= bufferSize) {\n                result.push(i);\n                lastTransient = i;\n            }\n        }\n        const prevX = frames[(i - bufferSize + frames.length) % frames.length];\n        sum += x2 - prevX * prevX;\n    }\n    return result;\n}\nfunction renderBuffer(ctx, canvas, audioCtx, frames, bpm) {\n    const framesPerBeat = Math.round(audioCtx.sampleRate * 60 / bpm);\n    const t = transients(frames);\n    ctx.fillStyle = '#6f6';\n    for (const i of t) {\n        ctx.fillRect(Math.round(i / frames.length * 1000) - 1, 0, 3, canvas.height);\n    }\n    let x = 0;\n    ctx.fillStyle = '#f992';\n    let framesUntilNextBeat = 0;\n    for (let i = 0; i < frames.length; ++i) {\n        const y = 200 * frames[i];\n        ctx.fillRect(x, 300 - y, 1, 2 * y);\n        if (framesUntilNextBeat <= 0) {\n            framesUntilNextBeat += framesPerBeat;\n            ctx.fillStyle = 'black';\n            ctx.fillRect(Math.round(x), 100, 1, canvas.height - 200);\n            ctx.fillStyle = '#f992';\n        }\n        framesUntilNextBeat -= 1;\n        x += 1000 / frames.length;\n    }\n}\nfunction initCanvas(body) {\n    const peaksCanvas = document.createElement('canvas');\n    peaksCanvas.id = 'peaks';\n    peaksCanvas.width = 1000;\n    peaksCanvas.height = 600;\n    body.appendChild(peaksCanvas);\n    const selectionCanvas = document.createElement('canvas');\n    selectionCanvas.id = 'selection';\n    selectionCanvas.width = 1000;\n    selectionCanvas.height = 600;\n    body.appendChild(selectionCanvas);\n    return [peaksCanvas, selectionCanvas];\n}\nclass Granules {\n    constructor(audioBuffer, audioCtx) {\n        this.audioBuffer = audioBuffer;\n        this.numSamples = audioBuffer.getChannelData(0).length;\n        this.audioCtx = audioCtx;\n        this.controlPoints = [0, this.numSamples / audioCtx.sampleRate];\n        this.activePoint = 0;\n    }\n    getXForPoint(index, canvas) {\n        const x = (canvas.width * this.controlPoints[index]) /\n            (this.numSamples / this.audioCtx.sampleRate);\n        return x;\n    }\n    render(canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = '#66f';\n        for (let i = 0; i < this.controlPoints.length - 1; ++i) {\n            const width = this.getXForPoint(i + 1, canvas) -\n                this.getXForPoint(i, canvas);\n            if (i === this.activePoint) {\n                ctx.fillStyle = '#aaf';\n            }\n            else if (i % 2 === 0) {\n                ctx.fillStyle = '#aaa';\n            }\n            else {\n                ctx.fillStyle = '#ddd';\n            }\n            ctx.fillRect(this.getXForPoint(i, canvas), 0, width, canvas.height);\n            1;\n        }\n    }\n    changeStart(delta) {\n        this.controlPoints[this.activePoint] =\n            Math.max(0, this.controlPoints[this.activePoint] + delta);\n    }\n    changeEnd(delta) {\n        this.controlPoints[this.activePoint + 1] += delta;\n    }\n    next(dir) {\n        this.activePoint += dir;\n        this.activePoint = this.activePoint % (this.controlPoints.length - 1);\n    }\n    play() {\n        console.log('playing');\n        const audioNode = this.audioCtx.createBufferSource();\n        audioNode.buffer = this.audioBuffer;\n        audioNode.connect(this.audioCtx.destination);\n        const duration = this.controlPoints[this.activePoint + 1]\n            - this.controlPoints[this.activePoint];\n        audioNode.start(0, this.controlPoints[this.activePoint], duration);\n    }\n    split() {\n        const mid = (this.controlPoints[this.activePoint] +\n            this.controlPoints[this.activePoint + 1]) / 2;\n        this.controlPoints.splice(this.activePoint + 1, 0, mid);\n    }\n}\nfunction go() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const audioCtx = yield common_1.Common.getContext();\n        const sampleUri = url.searchParams.get('s');\n        const gameTime = new gameTime_1.GameTime(120);\n        const sample = new sample_1.Sample(sampleUri, gameTime);\n        const buffer = yield sample.getData();\n        const body = document.getElementsByTagName('body')[0];\n        const [peaksCanvas, selectionCanvas] = initCanvas(body);\n        peaksCanvas.tabIndex = 0;\n        const peaksCtx = peaksCanvas.getContext('2d');\n        const frames = buffer.getChannelData(0);\n        const bpm = 110;\n        const granules = new Granules(buffer, audioCtx);\n        peaksCtx.clearRect(0, 0, peaksCanvas.width, peaksCanvas.height);\n        renderBuffer(peaksCtx, peaksCanvas, audioCtx, frames, bpm);\n        granules.render(selectionCanvas);\n        peaksCanvas.addEventListener('keydown', (ev) => {\n            let actionTaken = true;\n            switch (ev.code) {\n                case 'KeyS':\n                    granules.split();\n                    break;\n                case 'ArrowLeft':\n                    granules.changeStart(-0.01);\n                    break;\n                case 'ArrowRight':\n                    granules.changeStart(0.01);\n                    break;\n                case 'ArrowDown':\n                    granules.changeEnd(-0.01);\n                    break;\n                case 'ArrowUp':\n                    granules.changeEnd(0.01);\n                    break;\n                case 'Tab':\n                    if (ev.shiftKey) {\n                        granules.next(-1);\n                    }\n                    else {\n                        granules.next(1);\n                    }\n                    break;\n                case 'Space':\n                    granules.play();\n                    break;\n            }\n            if (actionTaken) {\n                ev.preventDefault();\n                selectionCanvas.getContext('2d')\n                    .clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);\n                granules.render(selectionCanvas);\n            }\n        });\n    });\n}\ngo();\n//# sourceMappingURL=open.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Sample = void 0;\nconst common_1 = require(\"./common\");\nclass Sample {\n    constructor(url, gameTime) {\n        this.url = url;\n        this.gameTime = gameTime;\n        this.audioCtx = null;\n        this.buffer = null;\n        this.init();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.buffer = yield this.getData();\n        });\n    }\n    getData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.audioCtx = yield common_1.Common.getContext();\n            const request = new XMLHttpRequest();\n            request.open('GET', this.url, true);\n            request.responseType = 'arraybuffer';\n            return new Promise((resolve, reject) => {\n                request.onload = () => {\n                    const audioData = request.response;\n                    this.audioCtx.decodeAudioData(audioData, function (buffer) {\n                        resolve(buffer);\n                    }, reject);\n                };\n                request.send();\n            });\n        });\n    }\n    _play(audioTimeS) {\n        if (!this.audioCtx || !this.buffer) {\n            console.error('Sample is not loaded!');\n            return;\n        }\n        const audioNode = this.audioCtx.createBufferSource();\n        audioNode.buffer = this.buffer;\n        audioNode.connect(this.audioCtx.destination);\n        const nowAudioTime = this.audioCtx.currentTime;\n        const timeInFuture = audioTimeS - nowAudioTime;\n        if (timeInFuture < 0) {\n            console.log(`Late: @${audioTimeS.toFixed(2)}`);\n        }\n        else {\n            console.log(`Early: @${audioTimeS.toFixed(2)}`);\n        }\n        audioNode.start(nowAudioTime + Math.max(timeInFuture, 0), Math.max(0, -timeInFuture));\n    }\n    playQuantized(gameTimeMs) {\n        const audioTimeS = this.gameTime.getAudioTimeForGameTime(gameTimeMs);\n        const quantizedAudioTimeS = this.gameTime.roundQuantizeAudioTime(audioTimeS);\n        this._play(quantizedAudioTimeS);\n    }\n}\nexports.Sample = Sample;\n//# sourceMappingURL=sample.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(367);\n"],"sourceRoot":""}